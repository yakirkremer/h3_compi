%{
    int yylex();
    #include "hw3_output.hpp"
    #include "types.h"
    #include "tables.h"
    using namespace output;
    extern int yylineno;
    void yyerror(const char*);
    SymbolTable tables(0,false);
%}


%token INT
%token BYTE
%token B
%token BOOL
%token TRUE
%token FALSE
%token RETURN

%token IF

%token WHILE
%token BREAK
%token CONTINUE
%token SC
%token ID
%token NUM
%token STRING


%right ASSIGN
%left OR
%left AND
%left EQUALITY
%left RELOP
%left ADDITIVE
%left MULTIPLICATIVE
%right NOT
%left LPAREN
%left RPAREN
%left LBRACE
%left RBRACE

%right ELSE

%%







Program: Statements                         {printProductionRule(1);}

Statements: Statement                       {printProductionRule(2);}
| Statements Statement            {printProductionRule(3);}

Statement: LBRACE Statements RBRACE         {printProductionRule(4);}
| VarDecl SC                       {printProductionRule(5);}
| Type ID ASSIGN Exp SC            {printProductionRule(6);}
| ID ASSIGN Exp SC                 {printProductionRule(7);}
| Call SC                          {printProductionRule(8);}
| RETURN SC                        {printProductionRule(9);}
| IF LPAREN Exp RPAREN Statement   {printProductionRule(10);}
| IF LPAREN Exp RPAREN Statement ELSE Statement    {printProductionRule(11);}
| WHILE LPAREN Exp RPAREN Statement    {printProductionRule(12);}
| BREAK SC                         {printProductionRule(13);}
| CONTINUE SC                      {printProductionRule(14);}
Call: ID LPAREN Exp RPAREN                  {printProductionRule(15);}

VarDecl: Type ID                          {$$ = new Decl(dynamic_cast<Type*>($1), $2);
                                            if(tables.symbol_exists($2->value)) {errorDef(yylineno, $2->value); exit(1);}
                                            tables.add_symbol($2->value,dynamic_cast<Type*>($1)->type, 4);}

VarUse: ID                             {if(!tables.symbol_exists($1.value)) {errorUndef(yylineno, $1.value); exit(1);}}

Type: INT                                   {$$ = new Type("int");}
| BYTE                                  {$$ = new Type("byte");}
| BOOL                                  {$$ = new Type("bool");}
|STRING                                 {$$ = new Type("string");}

Exp: LPAREN Exp RPAREN                      {cout<<"the expression value is"<<$1->value<<endl; printProductionRule(19);}
|ID                                     {printProductionRule(21);}
|Call                          {printProductionRule(22);}
|IntExp                                 {printProductionRule(23);}
|ByteExp                                {printProductionRule(24);}
|BoolExp                                {printProductionRule(24);}
|StringExp                              {printProductionRule(25);}


IntExp: NUM                                    {$$ = new Exp("int", $1);}
| IntExp ADDITIVE IntExp                    {printProductionRule(25);}
| IntExp MULTIPLICATIVE IntExp               {printProductionRule(26);}
| LPAREN INT RPAREN Exp                    {printProductionRule(27);}

ByteExp: NUM B                                  {$$ = new Exp("byte", $1);}
| NumExp ADDITIVE NumExp                    {printProductionRule(25);}
| NumExp MULTIPLICATIVE NumExp               {printProductionRule(26);}

StringExp: STRING                                 {$$ = new Exp("string", $1);}

BoolExp: TRUE                                   {$$ = new Exp("bool", $1);}
|FALSE                                  {$$ = new Exp("bool", $1);}
|NOT BoolExp                                {printProductionRule(28);}
| BoolExp AND BoolExp                            {printProductionRule(29);}
| BoolExp OR BoolExp                             {printProductionRule(30);}
| NumExp RELOP NumExp                          {printProductionRule(31);}


BoolExp: Exp EQUALITY Exp                       {printProductionRule(31);}
BoolExp: LPAREN Type RPAREN Exp                 {printProductionRule(32);}




%%

void yyerror(const char*) { errorSyn(yylineno); exit(1); }

int main() {
    return yyparse();
}
