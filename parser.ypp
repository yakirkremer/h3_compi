%{
    int yylex();
    #include "output.hpp"
    using namespace output;
    extern int yylineno;
    void yyerror(const char*);
%}


%token INT
%token BYTE
%token B
%token BOOL
%token TRUE
%token FALSE
%token RETURN

%token IF

%token WHILE
%token BREAK
%token CONTINUE
%token SC
%token ID
%token NUM
%token STRING


%right ASSIGN
%left OR
%left AND
%left EQUALITY
%left RELOP
%left ADDITIVE
%left MULTIPLICATIVE
%right NOT
%left LPAREN
%left RPAREN
%left LBRACE
%left RBRACE

%right ELSE

%%

Program: Statements                         {printProductionRule(1);}
Statements: Statement                       {printProductionRule(2);}
Statements: Statements Statement            {printProductionRule(3);}
Statement: LBRACE Statements RBRACE         {printProductionRule(4);}
Statement: Type ID SC                       {printProductionRule(5);}
Statement: Type ID ASSIGN Exp SC            {printProductionRule(6);}
Statement: ID ASSIGN Exp SC                 {printProductionRule(7);}
Statement: Call SC                          {printProductionRule(8);}
Statement: RETURN SC                        {printProductionRule(9);}
Statement: IF LPAREN Exp RPAREN Statement   {printProductionRule(10);}
Statement: IF LPAREN Exp RPAREN Statement ELSE Statement    {printProductionRule(11);}
Statement: WHILE LPAREN Exp RPAREN Statement    {printProductionRule(12);}
Statement: BREAK SC                         {printProductionRule(13);}
Statement: CONTINUE SC                      {printProductionRule(14);}
Call: ID LPAREN Exp RPAREN                  {printProductionRule(15);}
Type: INT                                   {printProductionRule(16);}
Type: BYTE                                  {printProductionRule(17);}
Type: BOOL                                  {printProductionRule(18);}
Exp: LPAREN Exp RPAREN                      {printProductionRule(19);}
Exp: Exp MULTIPLICATIVE Exp                 {printProductionRule(20);}
Exp: Exp ADDITIVE Exp                       {printProductionRule(20);}
Exp: ID                                     {printProductionRule(21);}
Exp: Call                                   {printProductionRule(22);}
Exp: NUM                                    {printProductionRule(23);}
Exp: NUM B                                  {printProductionRule(24);}
Exp: STRING                                 {printProductionRule(25);}
Exp: TRUE                                   {printProductionRule(26);}
Exp: FALSE                                  {printProductionRule(27);}
Exp: NOT Exp                                {printProductionRule(28);}
Exp: Exp AND Exp                            {printProductionRule(29);}
Exp: Exp OR Exp                             {printProductionRule(30);}
Exp: Exp RELOP Exp                          {printProductionRule(31);}
Exp: Exp EQUALITY Exp                       {printProductionRule(31);}
Exp: LPAREN Type RPAREN Exp                 {printProductionRule(32);}

%%

void yyerror(const char*) { errorSyn(yylineno); exit(1); }

int main() {
    return yyparse();
}
