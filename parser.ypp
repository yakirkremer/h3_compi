%{
    int yylex();
    #include "hw3_output.hpp"
    #include "types.h"
    #include "tables.h"
    //#define YYERROR_VERBOSE 1
    //#define YYDEBUG 1
    #define DEF_SIZE 1
    using namespace output;
    extern int yylineno;
    void yyerror(const char*);
    SymbolTable sym_table(0,false);

%}


%token INT
%token BYTE
%token B
%token BOOL
%token TRUE
%token FALSE
%token RETURN

%token IF

%token WHILE
%token BREAK
%token CONTINUE
%token SC
%token ID
%token NUM
%token STRING


%right ASSIGN
%left OR
%left AND
%left EQUALITY
%left RELOP
%left ADDITIVE
%left MULTIPLICATIVE
%right NOT
%left LPAREN
%left RPAREN
%left LBRACE
%left RBRACE

%right ELSE

%%


Program: Statements                         {printProductionRule(1);}
Statements:  Statement                       {printProductionRule(2);}
|  Statements Statement            {printProductionRule(3);}

Statement:  LBRACE Statements RBRACE         {printProductionRule(4);}
|  Decl SC                       {printProductionRule(5);}
|  Decl ASSIGN Exp SC            {if(!assign($3, $1, &sym_table)) yyerror("2");}
|  ID ASSIGN Exp SC                 {if(!assign($3, $1, &sym_table)) yyerror("2");}
|  Call SC                          {printProductionRule(8);}
|  RETURN SC                        {printProductionRule(9);}

|  IF LPAREN ExpBool RPAREN Statement   {printProductionRule(10);}
|  IF LPAREN ExpBool RPAREN Statement ELSE Statement    {printProductionRule(11);}

|  WHILE LPAREN Exp RPAREN Statement    {printProductionRule(12);}
|  BREAK SC                         {printProductionRule(13);}
|  CONTINUE SC                      {printProductionRule(14);}


Call: ID LPAREN Exp RPAREN                  { if(($$ = CreateCall($1,$3,&sym_table)) == nullptr) yyerror("2");}

Decl: Type ID                             {if(sym_table.add_symbol($2->name, dynamic_cast<Type*>($1)->type,  DEF_SIZE, false) == false) yyerror("2");$$ = new Decl($1,$2);}


Exp: ExpNum                                {}
| ExpStr                                {}

Type: INT                                   {$$ = new Type("int");}
Type: BYTE                                  {$$ = new Type("byte");}
Type: BOOL                                  {$$ = new Type("bool");}

Exp: LPAREN Exp RPAREN                      {}
Exp: Exp MULTIPLICATIVE Exp                 {printProductionRule(20);}
Exp: Exp ADDITIVE Exp                       {printProductionRule(20);}

Exp: ID                                     {if(($$ = CreateExp($1->name, &sym_table)) == nullptr) yyerror("2");}
Exp: Call                                   {if(($$ = CreateExp($1->name, &sym_table)) == nullptr) yyerror("2");}

ExpNum: NUM                                 {$$ = new ExpNum();}
| NUM B                                    {$$ = new ExpNumB();}
| ExpNum ADDITIVE ExpNum                    {$$ = new ExpNum();}
| ExpNum MULTIPLICATIVE ExpNum              {$$ = new ExpNum();}

ExpStr: STRING                                 {$$ = new ExpStr();}

ExpBool: TRUE                                   {$$ = new ExpBool();}
| FALSE                                  { $$ = new ExpBool();}
| NOT ExpBool                                {$$ = new ExpBool();}
| Exp AND Exp                            {$$ = new ExpBool();}
| Exp OR Exp                             {$$ = new ExpBool();}
| ExpNum RELOP ExpNum                          {$$ = new ExpBool();}
| ExpNum EQUALITY ExpNum                       {$$ = new ExpBool();}
| LPAREN Type RPAREN Exp                 {printProductionRule(32);}













%%

void yyerror( const char* yytext) {
    switch(atoi(yytext)) {
        case LEX_ERROR:
            output::errorLex(yylineno);
            break;
        case SYNTAX_ERROR:
            output::errorSyn(yylineno);
            break;
        case UNDEFINED_ERROR:
            output::errorUndef(yylineno, yytext);
            break;
        case DEFINED_ERROR:
            output::errorDef(yylineno, yytext);
            break;
        case UNDEFINED_FUNC_ERROR:
            output::errorUndefFunc(yylineno, yytext);
            break;
        case MISMATCH_ERROR:
            output::errorMismatch(yylineno);
            break;
        case PROTOTYPE_MISMATCH_ERROR:
            output::errorPrototypeMismatch(yylineno, yytext, "void");
            break;
        case UNEXPECTED_BREAK_ERROR:
            output::errorUnexpectedBreak(yylineno);
            break;
        case UNEXPECTED_CONTINUE_ERROR:
            output::errorUnexpectedContinue(yylineno);
            break;
        case BYTE_TOO_LARGE_ERROR:
            output::errorByteTooLarge(yylineno, yytext);
            break;

    }

    exit(1);

}

int main() {
    sym_table.add_symbol("print", "void", 1, true);
    sym_table.add_symbol("printi", "void", 1, true);
    sym_table.add_symbol("readi", "int", 1, true);
    //yydebug = 1;
    return yyparse();
}
