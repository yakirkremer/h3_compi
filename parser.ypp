%{
    int yylex();
    #include "hw3_output.hpp"
    #include "types.h"
    #include "tables.h"
    //#define YYERROR_VERBOSE 1
    //#define YYDEBUG 1
    #define DEF_SIZE 1
    using namespace output;
    extern int yylineno;
    void yyerror(const char*);
    extern Scopes sym_table_scopes = Scopes();


%}


%token INT
%token BYTE
%token B
%token BOOL
%token TRUE
%token FALSE
%token RETURN

%token IF

%token WHILE
%token BREAK
%token CONTINUE
%token SC
%token ID
%token NUM
%token STRING


%right ASSIGN
%left OR
%left AND
%left EQUALITY
%left RELOP
%left ADDITIVE
%left MULTIPLICATIVE
%right NOT
%left LPAREN
%left RPAREN
%left LBRACE
%left RBRACE

%right ELSE

%%
Program: Statements                         {endScope(sym_table_scopes.scope);}
Statements: Statement                       {printProductionRule(2);}
Statements: Statements Statement            {printProductionRule(3);}

Statement: LBRACE {sym_table_scopes.open_scope();} Statements RBRACE        {endScope(sym_table_scopes.scope);sym_table_scopes.close_scope();}

Statement: Type ID SC                       {$$ = new Statement($1, $2,yylineno);}
Statement: Type ID ASSIGN Exp SC            {$$ = new Statement($1, $2, dynamic_cast<Exp*>($4),yylineno, true);}

Statement: ID ASSIGN Exp SC                 {$$ = new Statement($1, $2, dynamic_cast<Exp*>($4),yylineno, false);}
Statement: Call SC                          {printProductionRule(8);}
Statement: RETURN SC                        {printProductionRule(9);}
Statement: IF LPAREN Exp RPAREN {sym_table_scopes.open_scope();} Statement   {endScope(sym_table_scopes.scope);sym_table_scopes.close_scope();}
Statement: IF LPAREN Exp RPAREN {sym_table_scopes.open_scope();} Statement {endScope(sym_table_scopes.scope);sym_table_scopes.close_scope();} ELSE {sym_table_scopes.open_scope();} Statement {endScope(sym_table_scopes.scope);sym_table_scopes.close_scope();}
Statement: WHILE LPAREN Exp RPAREN {sym_table_scopes.open_scope();} Statement {endScope(sym_table_scopes.scope);sym_table_scopes.close_scope();}
Statement: BREAK SC                         {printProductionRule(13);}
Statement: CONTINUE SC                      {printProductionRule(14);}

Call: ID LPAREN Exp RPAREN                  {$$ = new Call($1, dynamic_cast<Exp*>($3),yylineno);}

Type: INT                                   {}
Type: BYTE                                  {}
Type: BOOL                                  {}

Exp: LPAREN Exp RPAREN                      {printProductionRule(19);}

Exp: Exp MULTIPLICATIVE Exp                 {$$ = new Exp("binop", dynamic_cast<Exp*>($1), dynamic_cast<Exp*>($3),yylineno);}
Exp: Exp ADDITIVE Exp                       {$$ = new Exp("binop", dynamic_cast<Exp*>($1), dynamic_cast<Exp*>($3),yylineno);}

Exp: ID                                     {$$ = new Exp($1->name,$1,true,yylineno);}
Exp: Call                                   {$$ = new Exp($1->name,$1,true,yylineno);}

Exp: NUM                                    {$$ = new Exp("INT",$1);}
Exp: NUM B                                  {$$ = new Exp("BYTE",$1);}
Exp: STRING                                 {$$ = new Exp("STRING",$1);}
Exp: TRUE                                   {$$ = new Exp("BOOL",$1);}
Exp: FALSE                                  {$$ = new Exp("BOOL",$1);}

Exp: NOT Exp                                {$$ = new Exp("BOOL", $1->name, dynamic_cast<Exp*>($2), nullptr,yylineno);}
Exp: Exp AND Exp                            {$$ = new Exp("BOOL", $2->name, dynamic_cast<Exp*>($1), dynamic_cast<Exp*>($3),yylineno);}
Exp: Exp OR Exp                             {$$ = new Exp("BOOL", $2->name, dynamic_cast<Exp*>($1), dynamic_cast<Exp*>($3),yylineno);}
Exp: Exp RELOP Exp                          {$$ = new Exp("BOOL", "relop", dynamic_cast<Exp*>($1), dynamic_cast<Exp*>($3),yylineno);}
Exp: Exp EQUALITY Exp                       {$$ = new Exp("BOOL", "relop", dynamic_cast<Exp*>($1), dynamic_cast<Exp*>($3),yylineno);}

Exp: LPAREN Type RPAREN Exp                 {printProductionRule(32);}

%%



void yyerror( const char* yytext) {
    switch(atoi(yytext)) {
        case LEX_ERROR:
            output::errorLex(yylineno);
            break;
        case SYNTAX_ERROR:
            output::errorSyn(yylineno);
            break;
        case UNDEFINED_ERROR:
            output::errorUndef(yylineno, yytext);
            break;
        case DEFINED_ERROR:
            output::errorDef(yylineno, yytext);
            break;
        case UNDEFINED_FUNC_ERROR:
            output::errorUndefFunc(yylineno, yytext);
            break;
        case MISMATCH_ERROR:
            output::errorMismatch(yylineno);
            break;
        case PROTOTYPE_MISMATCH_ERROR:
            output::errorPrototypeMismatch(yylineno, yytext, "void");
            break;
        case UNEXPECTED_BREAK_ERROR:
            output::errorUnexpectedBreak(yylineno);
            break;
        case UNEXPECTED_CONTINUE_ERROR:
            output::errorUnexpectedContinue(yylineno);
            break;
        case BYTE_TOO_LARGE_ERROR:
            output::errorByteTooLarge(yylineno, yytext);
            break;

    }

    exit(1);

}

int main() {
    sym_table_scopes.add_symbol("print", "VOID", 0,{"STRING"}, true);
    sym_table_scopes.add_symbol("printi", "VOID", 0,{"num"}, true);
    sym_table_scopes.add_symbol("readi", "INT", 0,{"num"} ,true);
    //yydebug = 1;
    return yyparse();
}
